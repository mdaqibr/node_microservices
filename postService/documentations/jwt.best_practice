📌 🔒 1️⃣ Use strong secrets or keys
  Problem: If someone gets your signing secret, they can forge JWTs.

✅ Best practice:
  Never hardcode secrets — store them in environment variables (.env).
  Use a long, random secret (32+ chars) if using HS256 (HMAC).
  Or better: use asymmetric signing (RS256):
  User Service signs with private key.
  Other services verify with public key.
  More secure and easier for key rotation.

📌 🕒 2️⃣ Keep tokens short-lived
  Problem: If a token leaks, it’s valid until it expires.
  ✅ Best practice:
    Use short-lived access tokens (e.g. 15 mins).
    Issue refresh tokens (long-lived, HTTP-only cookie or secure storage) → client uses this to get new access tokens.

📌 🔁 3️⃣ Implement refresh token flow
  Why:
    You don’t want users logging in every 15 minutes.
    The refresh token flow gives you session-like control but stays stateless for services like Post Service.

✅ Pattern:
  Login → get accessToken + refreshToken.
  Client uses accessToken for APIs.
  When accessToken expires, client calls User Service /refresh with refreshToken → gets new accessToken.

📌 🗂️ 4️⃣ Use meaningful claims
  ✅ Include only what’s needed:
    E.g. { userId, role, permissions }
    Don’t stuff PII or sensitive data inside JWT → it’s base64-encoded, not encrypted.

📌 🚫 5️⃣ Protect against replay
  ✅ Use HTTPS — always.
    JWTs are bearer tokens → anyone with it can act as the user.
    No HTTPS → your token leaks in transit → game over.

📌 🧹 6️⃣ Handle revocation
  ✅ If you really must instantly revoke, do:
    Short-lived JWT + refresh token.
    Keep a revokedTokens or revokedUsers table → Post Service can check on critical ops.
    Or use a cache (Redis) to store blacklisted tokens for that short period.

📌 ⚡ 7️⃣ Minimize JWT size
  ✅ Keep payload small — remember it’s sent on every request.
  Avoid storing huge user data in the JWT.
  Store only id, role, scopes.

📌 ⚙️ 8️⃣ Rate-limit your auth endpoints
  ✅ Protect /login and /refresh from brute force → use rate limiting middleware like express-rate-limit.

📌 ✅ 9️⃣ Validate audience and issuer
  ✅ When verifying the JWT, check:
    aud (audience): e.g. post-service → so no other token for different service can slip through.
    iss (issuer): only trust your User Service as the issuer.

  const payload = jwt.verify(token, secret, {
    audience: 'post-service',
    issuer: 'user-service'
  });

📌 🏷️ 10️⃣ Version your JWT
  ✅ Add a version claim.
  If you ever change how you generate tokens, you can safely detect old ones and reject them if needed.

