ğŸ“Œ ğŸ”’ 1ï¸âƒ£ Use strong secrets or keys
  Problem: If someone gets your signing secret, they can forge JWTs.

âœ… Best practice:
  Never hardcode secrets â€” store them in environment variables (.env).
  Use a long, random secret (32+ chars) if using HS256 (HMAC).
  Or better: use asymmetric signing (RS256):
  User Service signs with private key.
  Other services verify with public key.
  More secure and easier for key rotation.

ğŸ“Œ ğŸ•’ 2ï¸âƒ£ Keep tokens short-lived
  Problem: If a token leaks, itâ€™s valid until it expires.
  âœ… Best practice:
    Use short-lived access tokens (e.g. 15 mins).
    Issue refresh tokens (long-lived, HTTP-only cookie or secure storage) â†’ client uses this to get new access tokens.

ğŸ“Œ ğŸ” 3ï¸âƒ£ Implement refresh token flow
  Why:
    You donâ€™t want users logging in every 15 minutes.
    The refresh token flow gives you session-like control but stays stateless for services like Post Service.

âœ… Pattern:
  Login â†’ get accessToken + refreshToken.
  Client uses accessToken for APIs.
  When accessToken expires, client calls User Service /refresh with refreshToken â†’ gets new accessToken.

ğŸ“Œ ğŸ—‚ï¸ 4ï¸âƒ£ Use meaningful claims
  âœ… Include only whatâ€™s needed:
    E.g. { userId, role, permissions }
    Donâ€™t stuff PII or sensitive data inside JWT â†’ itâ€™s base64-encoded, not encrypted.

ğŸ“Œ ğŸš« 5ï¸âƒ£ Protect against replay
  âœ… Use HTTPS â€” always.
    JWTs are bearer tokens â†’ anyone with it can act as the user.
    No HTTPS â†’ your token leaks in transit â†’ game over.

ğŸ“Œ ğŸ§¹ 6ï¸âƒ£ Handle revocation
  âœ… If you really must instantly revoke, do:
    Short-lived JWT + refresh token.
    Keep a revokedTokens or revokedUsers table â†’ Post Service can check on critical ops.
    Or use a cache (Redis) to store blacklisted tokens for that short period.

ğŸ“Œ âš¡ 7ï¸âƒ£ Minimize JWT size
  âœ… Keep payload small â€” remember itâ€™s sent on every request.
  Avoid storing huge user data in the JWT.
  Store only id, role, scopes.

ğŸ“Œ âš™ï¸ 8ï¸âƒ£ Rate-limit your auth endpoints
  âœ… Protect /login and /refresh from brute force â†’ use rate limiting middleware like express-rate-limit.

ğŸ“Œ âœ… 9ï¸âƒ£ Validate audience and issuer
  âœ… When verifying the JWT, check:
    aud (audience): e.g. post-service â†’ so no other token for different service can slip through.
    iss (issuer): only trust your User Service as the issuer.

  const payload = jwt.verify(token, secret, {
    audience: 'post-service',
    issuer: 'user-service'
  });

ğŸ“Œ ğŸ·ï¸ 10ï¸âƒ£ Version your JWT
  âœ… Add a version claim.
  If you ever change how you generate tokens, you can safely detect old ones and reject them if needed.

